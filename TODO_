ПОЧЕМУ ОН ОТКЛЮЧАЕТСЯ ЫВАЫАЫВАЫ



std::string get_responses_string(HttpConnection &connection) {
  // std::cout << connection.recv_stream.str();
  (void)connection;
  return "HTTP/1.1 200 OK\r\n"
         "Content-Type: text/plain\r\n"
         "Content-Length: 12\r\n"
         "\r\n"
         "Hello world!" + Libft::ft_itos(connection.serv->srv_sockaddr.sin_port);
}

5. Write test and case-by-case comparisons for all of the libft methods.
6. Replace all non-libft functions to libft methods




----------------------------------------------------------------------------------------------------------------------------------

Write route parser
dffdffdf


1. Choose the port and host of each ’server’.
2. Setup the server_names or not.
3. The first server for a host:port will be the default for this host:port (that means it will answer to all the requests that don’t belong to an other server).
4. Setup default error pages.
5. Limit client body size.
6. Setup routes with one or multiple of the following rules/configuration (routes wont
be using regexp):
  6.1 Define a list of accepted HTTP methods for the route.
  6.2 Define a HTTP redirection.
  6.3 Define a directory or a file from where the file should be searched (for example, if url /kapouet is rooted to /tmp/www, url /kapouet/pouic/toto/pouet is /tmp/www/pouic/toto/pouet).
  6.4 Turn on or off directory listing.
  6.5 Set a default file to answer if the request is a directory.
  6.6 Execute CGI based on certain file extension (for example .php).
  6.7 Make it work with POST and GET methods.
  6.8 Make the route able to accept uploaded files and configure where they should
be saved.
∗ Do you wonder what a CGI is?
∗ Because you won’t call the CGI directly, use the full path as PATH_INFO.
∗ Just remember that, for chunked request, your server needs to unchunk
it, the CGI will expect EOF as end of the body.
∗ Same things for the output of the CGI. If no content_length is returned
from the CGI, EOF will mark the end of the returned data.
∗ Your program should call the CGI with the file requested as first argument.
∗ The CGI should be run in the correct directory for relative path file access.
∗ Your server should work with one CGI (php-CGI, Python, and so forth).
You must provide some configuration files and default basic files to test and demonstrate every feature works during evaluation.




[x] Переделать метод словаря так, чтобы можно было
        сохранять контент с глубиной больше 1
        и потом констрактить новый конфиг из value и изучать его контент

Перечислить все что будет в Конфиге "server"
  1. Перечислить и прописать какой будет у кофнига формат
  2. Создать структуры данных для этого дела в Server.cpp
  3. Написать конструктор, который будет читать сервер конфиг
      и записывать всю нужную инфу в стуктуры



написать нормальный констрактор-лоадер для сервера
написать логику чтения конфига и создания нескольких серверов!



I removed close() pipe from HttpConnection destructor
I need to do it manually





3. Rework return values so the indicate if read/write/recv/send was or was not called - create enum for it
4. Придумать, как парсить рауты из конфига - просто записывать рауты по-другому и брать вектор раутов





1. Настроить нормальную выгрузку данных из конфига в сервера
    с сохранением рутов итд
4. add Server& link to HttpConnection
5. change logic in all functions that are already written - map instead of the vector, take into account serv class, etc
6. разобраться с форматом айпи во всех местах сервера
  думаю хранить в структуре сишной все-таки
Засунуть везде где надо таймаут чеки и обновление последней активности




add timestamps to logger









1. Find a cfg function chat checks the existence of the key without any exceptions
2. 





what if the request if for cgi
u need to check keep-alive so I can know if I need to close the socket or not
we are reading from the cgi in a blocking way in this architecture



todo:
FI_Xes
Cleanup, timeouts, etc























; Нарисовать диаграмму действий
;Rename Connection class to ConnectionManager, has a map <fd, HttpConnection>
; create HttpConnection class that is basically what they call "clientdata"
; 1. прочитать чатгпт
; Разобраться, как работает конфиг, и что он содержит.


; Написать нормальный констуктор для ХттпКоннекшн

;Написать поля и методы (скелет) для ХттпРеквест и ХттпРеспонс (взять из википедии)

Прочитать RFC 9110 и 9112

Добавить документацию по минимуму

сделать все фиксы на которые хватит сил

сделать поллаут модуль (скелет)



Нарисовать новую диаграмму по моему коду и подумать че куда надо вставить
Добавить fcntl(newsockfd, F_SETFL, O_NONBLOCK | FD_CLOEXEC) при каждом создании fd
удалить чеки еррнО, если они естьs




































МЫ НИЧКГО НЕ ПИШЕМ В ПАЙП ФОРКУ, ВСЯ ИНФА ПЕРЕДАËТСЯ СРАЗУ ЧЕРЕЗ execve в массиве строк!





; 1. write send/recv chunk, accept_
; 2. написать полный функционал (с функциями-затычками для других модулей, СГИ, конфига, и так далее)
;       void handle_read(int fd);
;       void handle_accept(int fd);
;       void handle_cgi_output(int cgi_pipe_fd);
;       void handle_incoming_data(int fd);
;      void handle_write(int fd)
;      handle_request_if_ready(int fd)
; 3. Убедиться, что при каких-либо изменениях я всегда обновляю все структуры
4. Отформатировать код, закинуть в главную папку, закоммитить
5. Просто сесть и прочитать рфц или как их там.
6. Разобраться, как работает конфиг
7. Переименовать коннекшн класс, привести его в ортодокс форму, добавить выгрузку данных из конфига.
8. Добавить файлы в select цикл




list of things in select:
1. read from socket
  if read max buf size, do nothing, if read less, send it to requestHandler
  2. then do something with the request if it is complete
2. write to socket
3. read from CGI pipe to socket buffer
4. reaading from file and writing to socket buffer


possible status problems:
1. Waiting for several CGI responses

1. get a request
2. send it to CGI
3. get req2
4. send it to cgi
5. get req3 and send it to responsegenerator
6. responsgenerator returns and I send a chunk of the response
7. I get something from CGI and add it 


3.1 Выяснить, как сделать всё нонблокинг, и сделать всё нонблокинг (прочитать про все три разрешённых флага!)



socket 5:

waits for cgi in fd 7
waits for cgi in fd 8

i store CGI response in asyncFD which is CGI pipe fd, not socket fd
then I write 






I store Responses and Requests


HTTP/1.1 does not include a request identifier for associating
a given request message with its corresponding one or more
response messages. Hence, it relies on the order of response
arrival to correspond exactly to the order in which requests
are made on the same connection. 

remove bzero - it's not allowed'


[x] 0. make format(create the rule and run it), re-read all of the code, cleanup the directories from any files that I don't need'
[x] if start_server() is called for 2nd time and returns -1, is the first server cleaned up?
[x] or does this event not even cause the program to terminate?

[x] 2. Decide where to store each timeout and respective timer
[x] 3. Create variables for timers and timeout values, add them to all of the constructors
[x] 4. Add setting timeout values from config to ConnectionManager Setup
[x] 5. Add timer tracking everywhere
[x] 6. Add cleanup everywhere where it is necessary

[x] 1. Add timeout checks not only in cleanup() but before every action that is taken on the connection.
[x] 2. use conn_timed_out in cleanup()
[x] 3. use cgi_timed_out also (compare them with what I have done in cleanup())
[x] 7. Add descriptions (detailed) to every function that I have written
[x] 8. fix libft functions that already exist!

write functions:
[x] 1. Libft::ft_inet_pton
[x] 2. ConnectionManager::terminate() function that cleans everything up and stops the server.
[x] 3. Libft::memset for bzero
[x] 3. A function to shut down one Server instance with all its derivative objects.
[x] 4. handle_poll_problem
[x] 5. run->what if handle_fds returns -1 - close either one server or the whole webserv correctly



1. Make a list of timeouts that I need to keep track of

  ! time_t difftime returns seconds in double format
  ! timouts are stored in Config in mililseconds so we need to convert

  1. Client Request Timeout
    Limits how long the server waits for the client to send the complete HTTP request.
    Also the same time is allocated for webserv to send the response back to the client
    During the request phase when the client is sending data (headers and body) to the server.
    - defined for each Server instance
      - kept track of in each HttpConnections
    - stored in config
    - timer starts before with the first recv() and not updated with the following recv()s.
    - timer starts again before the first send() and not updated with the following send()s.
    - if ((!reading_req_in_process || sending_resp_in_processs)
                                   && duration > timeout) 
        then close the connection. (w/ cleanup!)
  2. Client Connection Timeout
    - defined for each keep-alive connection (HttpConnection class)
    - stored inside the request itselfs
    - starts when the response is sent and keep-alive is true
    - if (noting_is_happening_on_socket && duration > timeout) then close the keep-alive connection


  3. Upstream (Backend) Timeout - CGI timeout
    - defined for each Server class
    - Taken from Config in each Server block
    - Timer start when the CGI is ()-d
    - if (cgi_in_process && duration > timeout) then kill the cgi and prepare and send error to the client

