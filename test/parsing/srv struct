// 1. Choose the port and host of each ’server’.
struct sockaddr_in srv_sockaddr; {
  short            sin_family;   // e.g. AF_INET
  unsigned short   sin_port;     // e.g. htons(3490)
  struct in_addr   sin_addr;     // see struct in_addr, below
  char             sin_zero[8];  // zero this if you want to
};
// 2. Setup the server_names or not.


3. The first server for a host:port will be the default for this host:port (that means it will answer to all the requests that don’t belong to an other server).
4. Setup default error pages.
5. Limit client body size.
6. Setup routes with one or multiple of the following rules/configuration (routes wont
be using regexp):
  6.1 Define a list of accepted HTTP methods for the route.
  6.2 Define a HTTP redirection.
  6.3 Define a directory or a file from where the file should be searched (for example, if url /kapouet is rooted to /tmp/www, url /kapouet/pouic/toto/pouet is /tmp/www/pouic/toto/pouet).
  6.4 Turn on or off directory listing.
  6.5 Set a default file to answer if the request is a directory.
  6.6 Execute CGI based on certain file extension (for example .php).
  6.7 Make it work with POST and GET methods.
  6.8 Make the route able to accept uploaded files and configure where they should
be saved.


unsingned long host
unsigned long port (or inside the struct?)
std::vector<std::string> server_names - split by " "
std::vector<DefaultPage> default_pages
    struct DefaultPage{
      string page_name;
      string html_file;
      string location;
      bool internal;
    }
size_t client_max_body_size;
std::vector<Route> routes;
    struct Route {
      string path
      string filename
      // some of more stuff idk
    }








std::map<string, string> Config::get_content_dict() {
    std::map<string, string> content;
    bool in_quote = false;
    int curly_depth = 0;
    (void)curly_depth;
    bool is_key = true;
    std::string key, value;
  
    size_t i = 1;
    while (i < content_.size()) {
        char c = content_[i];
        if (c == '"') {
            in_quote = !in_quote;
            continue;
        }
        if (in_quote) {
            if (is_key) {
                key += c;
            } else {
                value += c;
            }
        } else {
            if (c == ':') {
                is_key = false;
            } else if (c == ',') {
                if (!key.empty() && !value.empty()) {
                    content[key] = value;
                }
                key.clear();
                value.clear();
                is_key = true;
            } else if (c == '}') {
                if (!key.empty() && !value.empty()) {
                    content[key] = value;
                }
                break;
            } 
            // else if (!is_key && !in_quote && c == '{' && value.empty()) {
            //   std::cout << "a";
            //   curly_depth = 0;
            //   while (i < content_.size() && curly_depth != 0) {
            //     if (content_[i] == '{') {
            //       curly_depth += 1;
            //     }
            //     if (content_[i] == '}') {
            //       curly_depth -= 1;
            //     }
            //     value += content_[i];
            //     ++i;
            //   }
            // }
        }
      ++i;
    }
    return content;
}



OLD:


    for (size_t i = 1; i < content_.size(); ++i) {
        char c = content_[i];
        if (c == '{' && !in_quote) {
          throw std::invalid_argument("Dict representaion of the content impossible - nested content (depth > 0): " + content_); 
        }
        if (c == '"') {
            in_quote = !in_quote;
            continue;
        }
        if (in_quote) {
            if (is_key) {
                key += c;
            } else {
                value += c;
            }
        } else {
            if (c == ':') {
                is_key = false;
            } else if (c == ',') {
                if (!key.empty() && !value.empty()) {
                    content[key] = value;
                }
                key.clear();
                value.clear();
                is_key = true;
            } else if (c == '}') {
                if (!key.empty() && !value.empty()) {
                    content[key] = value;
                }
                break;
            }
        }
    }
    return content;
}