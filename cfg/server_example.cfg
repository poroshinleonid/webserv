{
    "server": {
        "host": "127.0.0.1",
        "port": "8080",
        "server_name" : "example.com www.example.com",
        "default_pages" : {
          "404" : {
            "html_file" : "404.html", 
            "location" : "~/personal/webserv/YoupiBanane/",
            "internal" : "true/false"
          }
          "666" : {
            "html_file" : "666.html", 
            "location" : "~/personal/webserv/YoupiBanane/",
            "internal" : "true/false"
          }
        }
        "client_max_body_size" : "228",
        "routes": {
            "home": "/",
            "login": "tae",
            "logout": "/logout",
            "profile": "/user/profile"
        },
    },
}

unsingned long host
unsigned long port (or inside the struct?)
std::vector<std::string> server_names - split by " "
std::vector<DefaultPage> default_pages
    struct DefaultPage{
      string page_name;
      string html_file;
      string location;
      bool internal;
    }
size_t client_max_body_size;
std::vector<Route> routes;
    struct Route {
      string path
      string filename
      // some of more stuff idk
    }








std::map<string, string> Config::get_content_dict() {
    std::map<string, string> content;
    bool in_quote = false;
    int curly_depth = 0;
    (void)curly_depth;
    bool is_key = true;
    std::string key, value;
  
    size_t i = 1;
    while (i < content_.size()) {
        char c = content_[i];
        if (c == '"') {
            in_quote = !in_quote;
            continue;
        }
        if (in_quote) {
            if (is_key) {
                key += c;
            } else {
                value += c;
            }
        } else {
            if (c == ':') {
                is_key = false;
            } else if (c == ',') {
                if (!key.empty() && !value.empty()) {
                    content[key] = value;
                }
                key.clear();
                value.clear();
                is_key = true;
            } else if (c == '}') {
                if (!key.empty() && !value.empty()) {
                    content[key] = value;
                }
                break;
            } 
            // else if (!is_key && !in_quote && c == '{' && value.empty()) {
            //   std::cout << "a";
            //   curly_depth = 0;
            //   while (i < content_.size() && curly_depth != 0) {
            //     if (content_[i] == '{') {
            //       curly_depth += 1;
            //     }
            //     if (content_[i] == '}') {
            //       curly_depth -= 1;
            //     }
            //     value += content_[i];
            //     ++i;
            //   }
            // }
        }
      ++i;
    }
    return content;
}



OLD:


    for (size_t i = 1; i < content_.size(); ++i) {
        char c = content_[i];
        if (c == '{' && !in_quote) {
          throw std::invalid_argument("Dict representaion of the content impossible - nested content (depth > 0): " + content_); 
        }
        if (c == '"') {
            in_quote = !in_quote;
            continue;
        }
        if (in_quote) {
            if (is_key) {
                key += c;
            } else {
                value += c;
            }
        } else {
            if (c == ':') {
                is_key = false;
            } else if (c == ',') {
                if (!key.empty() && !value.empty()) {
                    content[key] = value;
                }
                key.clear();
                value.clear();
                is_key = true;
            } else if (c == '}') {
                if (!key.empty() && !value.empty()) {
                    content[key] = value;
                }
                break;
            }
        }
    }
    return content;
}